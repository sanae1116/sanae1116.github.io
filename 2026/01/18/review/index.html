  <!DOCTYPE html>
  <html lang="zh-CN"  
      data-theme-mode="auto"
  >
  <head>
  <meta charset="utf-8">
  
  
  
  <script>window.REIMU_CONFIG = {};window.REIMU_CONFIG.icon_font = '4552607_4k4bc36ef96';window.REIMU_CONFIG.clipboard_tips = {"success":{"zh-CN":"复制成功 (*^▽^*)"},"fail":{"zh-CN":"复制失败 (ﾟ⊿ﾟ)ﾂ"},"copyright":{"enable":false,"count":50,"license_type":"by-nc-sa"}};window.REIMU_CONFIG.clipboard_tips.copyright.content = '本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！';window.REIMU_CONFIG.code_block = {"expand":true};window.REIMU_CONFIG.base = 'http://example.com';</script>
  <title>
    C++ primer plus review | Sanae&#39;s Space
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="preload" as="style" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic|Noto Serif SC:400,400italic,700,700italic&display=swap"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic|Noto Serif SC:400,400italic,700,700italic&display=swap" media="print" onload="this.media='all'">
    <link rel="preload" href="//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2" as="font" type="font/woff2" crossorigin="anonymous">
    
<link rel="stylesheet" href="/css/loader.css">

    <meta name="description" content="C++基础1.iostream 和using namespace std;看源码，iostream包含了C++中io的对象（不是函数），最常用的为cin，cout，在std命名空间。std 命名空间包含了C++标准库中所有的标识符 1234567891011121314&#x2F;&#x2F; 命名冲突示例#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F; 假设我们自己定义">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ primer plus review">
<meta property="og:url" content="http://example.com/2026/01/18/review/index.html">
<meta property="og:site_name" content="Sanae&#39;s Space">
<meta property="og:description" content="C++基础1.iostream 和using namespace std;看源码，iostream包含了C++中io的对象（不是函数），最常用的为cin，cout，在std命名空间。std 命名空间包含了C++标准库中所有的标识符 1234567891011121314&#x2F;&#x2F; 命名冲突示例#include &lt;iostream&gt;using namespace std;&#x2F;&#x2F; 假设我们自己定义">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2026-01-18T08:48:21.026Z">
<meta property="article:modified_time" content="2026-01-18T08:49:03.881Z">
<meta property="article:author" content="Sanae">
<meta name="twitter:card" content="summary">
    <link rel="alternate" href="/atom.xml" title="Sanae's Space" type="application/atom+xml">
    <link rel="shortcut icon" href="/images/favicon.jpg">
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css" integrity="sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx/1oA/0l8ysE" crossorigin="anonymous">
    
<script src="https://npm.webcache.cn/pace-js@1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous"></script>

    
<link rel="stylesheet" href="https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css" integrity="sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa" crossorigin="anonymous">

<meta name="generator" content="Hexo 8.1.1"></head>

  <body>
      <div id='loader'>
    <div class="loading-left-bg loading-bg"></div>
    <div class="loading-right-bg loading-bg"></div>
    <div class="spinner-box">
      <div class="loading-taichi rotate">
          <svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" version="1.1" xmlns="https://www.w3.org/2000/svg" shape-rendering="geometricPrecision">
            <path d="M303.5 432A80 80 0 0 1 291.5 592A80 80 0 0 1 303.5 432z" fill="var(--red-1, #ff5252)" />
            <path d="M512 65A447 447 0 0 1 512 959L512 929A417 417 0 0 0 512 95A417 417 0 0 0 512 929L512 959A447 447 0 0 1 512 65z 
           M512 95A417 417 0 0 1 929 512A208.5 208.5 0 0 1 720.5 720.5L720.5 592A80 80 0 0 0 720.5 432A80 80 0 0 0 720.5 592L720.5 720.5A208.5 208.5 0 0 1 512 512A208.5 208.5 0 0 0 303.5 303.5A208.5 208.5 0 0 0 95 512A417 417 0 0 1 512 95z" fill="var(--red-1, #ff5252)" />
          </svg>
      </div>
      <div class="loading-word">少女祈祷中...</div>
    </div>
  </div>
  </div>
  <script>
    var time = null;
    var loaderEl = document.getElementById('loader');
    var startLoading = () => {
      time = Date.now();
      loaderEl.classList.remove("loading");
    }
    var hideLoader = () => {
      document.body.style.overflow = 'auto';
      loader.classList.add('loading');
    };

    var endLoading = () => {
      if (!time) {
        hideLoader();
      } else {
        if (Date.now() - time > 500) {
          time = null;
          hideLoader();
        } else {
          setTimeout(endLoading, 500 - (Date.now() - time));
          time = null;
        }
      }
    }
    window.addEventListener('DOMContentLoaded', endLoading);
    loaderEl.addEventListener('click', endLoading);
  </script>
<div id="copy-tooltip"></div>
<div id="heatmap-tooltip"></div>


    <div id="container">
      <div id="wrap">
        <div id="header-nav">
  <nav id="main-nav" aria-label="Primary navigation">
        <a class="main-nav-link-wrap" href="/">
            <div class="main-nav-icon icon rotate">
                &#xe62b;
            </div>
          <span class="main-nav-link">首页</span>
        </span>
        <a class="main-nav-link-wrap" href="/archives">
            <div class="main-nav-icon icon rotate">
                &#xe62b;
            </div>
          <span class="main-nav-link">归档</span>
        </span>
        <a class="main-nav-link-wrap" href="/about">
            <div class="main-nav-icon icon rotate">
                &#xe62b;
            </div>
          <span class="main-nav-link">关于</span>
        </span>
        <a class="main-nav-link-wrap" href="/friend">
            <div class="main-nav-icon icon rotate">
                &#xe62b;
            </div>
          <span class="main-nav-link">友链</span>
        </span>
    <a id="main-nav-toggle" class="nav-icon" aria-label="Toggle navigation" role="button"></a>
  </nav>
  <nav id="sub-nav" aria-label="Secondary navigation">
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅" aria-label="RSS 订阅" target="_blank"></a>
  </nav>
</div>
<header id="header" aria-label="Site header">
        <picture>
        </picture>
          <img  fetchpriority="high" src="/images/bg1.webp" alt="C++ primer plus review">
  <div id="header-outer">
    <div id="header-title">
          <span id="logo">
            <h1 data-aos="slide-up">C++ primer plus review</h1>
          </span>
        <h2 id="subtitle-wrap" data-aos="slide-down">
        </h2>
    </div>
  </div>
</header>

        <div id="content" aria-label="Page content"  class="sidebar-right" >
          <aside id="sidebar" aria-label="Sidebar">
  <div class="sidebar-wrapper-container sticky">
  <div class="sidebar-wrapper">
    <div class="sidebar-wrap" data-aos="fade-up">
          <div class="sidebar-toc-sidebar"><h3 class="toc-title">文章目录</h3>
<div class="sidebar-toc-wrapper toc-div-class" >
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-iostream-%E5%92%8Cusing-namespace-std"><span class="toc-number">1.1.</span> <span class="toc-text">1.iostream 和using namespace std;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-cin-getline-%E5%92%8C-cin-get-%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">2.cin.getline() 和 cin.get()读入字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%87%E9%92%88%E3%80%81new%E3%80%81delete"><span class="toc-number">1.3.</span> <span class="toc-text">3.指针、new、delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-typedef-%E5%88%AB%E5%90%8D"><span class="toc-number">1.4.</span> <span class="toc-text">4.typedef 别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-number">1.5.</span> <span class="toc-text">5.小插曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-11%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.</span> <span class="toc-text">6.C++11基于范围的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-cin-cout%E5%AF%B9%E6%AF%94scanf-printf"><span class="toc-number">1.7.</span> <span class="toc-text">7.cin&#x2F;cout对比scanf&#x2F;printf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.8.</span> <span class="toc-text">8. 函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-C-%E5%87%BD%E6%95%B0%E6%96%B0%E7%89%B9%E6%80%A7-inline%E5%AF%B9%E4%BA%8E-define%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3"><span class="toc-number">1.9.</span> <span class="toc-text">9.C++函数新特性:inline对于#define宏函数的替代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%BC%95%E7%94%A8"><span class="toc-number">1.10.</span> <span class="toc-text">10.引用&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">11.函数默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.</span> <span class="toc-text">12.函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.13.</span> <span class="toc-text">13.函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-namespace-%E5%92%8C-using"><span class="toc-number">1.14.</span> <span class="toc-text">14.namespace 和 using</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP"><span class="toc-number">2.</span> <span class="toc-text">OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-OOP%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">1.OOP思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BBclass"><span class="toc-number">2.2.</span> <span class="toc-text">2.类class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8B%E5%85%83"><span class="toc-number">2.3.</span> <span class="toc-text">3.友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.4.</span> <span class="toc-text">4.类和动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">5.类继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">6.C++中的代码重用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.7.</span> <span class="toc-text">7.类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">2.8.</span> <span class="toc-text">8.友元、异常和其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-RTTI"><span class="toc-number">2.9.</span> <span class="toc-text">9.RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.10.</span> <span class="toc-text">10.类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.11.</span> <span class="toc-text">11.智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-STL"><span class="toc-number">2.12.</span> <span class="toc-text">12.STL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%B8%B8%E8%A7%81STL%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.13.</span> <span class="toc-text">13.常见STL的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3C"><span class="toc-number">3.</span> <span class="toc-text">现代C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">3.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">移动语义与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">并发与多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.6.</span> <span class="toc-text">范围for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">3.7.</span> <span class="toc-text">constexpr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">杂项</span></a></li></ol>
</div>
</div>
          <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="Sanae" class="lazyload">
  <div class="sidebar-author-name">Sanae</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">2</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social" >
</div>
<div class="sidebar-menu">
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
</div>
</div>
          <div class="sidebar-btn-wrapper" style="position:static">
            <div class="sidebar-toc-btn current"></div>
            <div class="sidebar-common-btn"></div>
          </div>
    </div>
  </div>
  <div class="sidebar-widget">
  </div>
  </div>
</aside>

          <section id="main" aria-label="Main content"><article id="post-review" class="h-entry article" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-inner" data-aos="fade-up">
    <div class="article-meta">
      <div class="article-date">
  <span class="article-date-link icon-calendar" data-aos="zoom-in">
    <time datetime="2026-01-18T08:48:21.026Z" itemprop="datePublished">2026-01-18</time>
    <time style="display: none;" id="post-update-time">2026-01-18</time>
  </span>
</div>

    </div>
    
    <div class="hr-line"></div>
    
    <div class="e-content article-entry" itemprop="articleBody">
        <h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="1-iostream-和using-namespace-std"><a href="#1-iostream-和using-namespace-std" class="headerlink" title="1.iostream 和using namespace std;"></a>1.iostream 和using namespace std;</h3><p>看源码，iostream包含了C++中io的对象（不是函数），最常用的为cin，cout，在std命名空间。std 命名空间包含了C++标准库中所有的标识符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名冲突示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设我们自己定义了一个 count 函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里会产生歧义：是调用 std::count 还是我们自己定义的 count？</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count</span>() &lt;&lt; endl;  <span class="comment">// 编译错误：ambiguous call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cout的对象属性包括一个插入运算符（&lt;&lt;)，它可以将其右侧的信息插入到流中。<br>cin同理。其中还包含运算符重载。</p>
<h3 id="2-cin-getline-和-cin-get-读入字符串"><a href="#2-cin-getline-和-cin-get-读入字符串" class="headerlink" title="2.cin.getline() 和 cin.get()读入字符串"></a>2.cin.getline() 和 cin.get()读入字符串</h3><h3 id="3-指针、new、delete"><a href="#3-指针、new、delete" class="headerlink" title="3.指针、new、delete"></a>3.指针、new、delete</h3><p>C++的指针声明可以如下格式区别解引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br></pre></td></tr></table></figure>
<p>注意事项：解引用前一定要将指针指向一个正确的地方。如下操作可能引发严重问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p;</span><br><span class="line">*p = <span class="number">123456</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*a = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span>* b = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">*b = <span class="number">100.0</span>;</span><br><span class="line"><span class="keyword">delete</span> a;</span><br><span class="line"><span class="keyword">delete</span> b;</span><br></pre></td></tr></table></figure>
<p>new从堆的内存区取空间。new和delete一定要配对。delete只能释放new分配的内存，但对空指针delete也没问题。<br>new可以用于创建动态数组。如果原来没有[]，delete也不能有。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">short</span>* ps = <span class="keyword">new</span> <span class="type">short</span> [<span class="number">500</span>];</span><br><span class="line"><span class="keyword">delete</span> pt;</span><br><span class="line"><span class="keyword">delete</span> [] ps;</span><br></pre></td></tr></table></figure>
<p>指针算术：指针加一等于增加它指向的类型的字节数。<br>new 和 delete有关动态存储，即手动内存管理，更灵活。<br>动态数组模板类vector。<br>动态的含义：“动态” 指的是在程序运行时（runtime） 决定和改变，而不是在编译时（compile-time）固定。<br>new所说的那个动态数组，代表的是分配时刻的动态性，不是在编译时确定的，但是一确定之后跟普通数组的使用无区别（内存有区别，还需要delete管理）。但是vector数组还能改长度，并且是自动管理内存。</p>
<h3 id="4-typedef-别名"><a href="#4-typedef-别名" class="headerlink" title="4.typedef 别名"></a>4.typedef 别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br></pre></td></tr></table></figure>
<h3 id="5-小插曲"><a href="#5-小插曲" class="headerlink" title="5.小插曲"></a>5.小插曲</h3><p>沟槽的国产输入法（我用的百度输入法），shift+space直接给我切换到全角中文了，字体啥的全变了。但是微软输入法或者纯英文键盘不会有这个问题，之前vscode做笔记啥的就问题挺大。然而微软输入法的中文又是纯智障。</p>
<h3 id="6-C-11基于范围的for循环"><a href="#6-C-11基于范围的for循环" class="headerlink" title="6.C++11基于范围的for循环"></a>6.C++11基于范围的for循环</h3><p>个人感觉类似python</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> x : prices)</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="7-cin-cout对比scanf-printf"><a href="#7-cin-cout对比scanf-printf" class="headerlink" title="7.cin&#x2F;cout对比scanf&#x2F;printf"></a>7.cin&#x2F;cout对比scanf&#x2F;printf</h3><p>当年我学信竞的时候，都说的是别用cin&#x2F;cout，因为速度原因。因为那段时间的cin&#x2F;cout默认和C stdio 同步，这允许混用C和C++的I&#x2F;O，但带来了额外开销，同步 &#x3D; 每次 IO 都加锁 + flush + locale 处理。<br>但这是早期编译器优化不行＋评测机硬件纯fw的结果，但是现在已经不是这样的了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); <span class="comment">// 关闭与 stdio 的同步</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);            <span class="comment">// 解除 cin 与 cout 的绑定</span></span><br></pre></td></tr></table></figure>
<p>这个可以使流输入输出追平scanf&#x2F;printf，甚至更快。当然如果不加这俩还是慢。<br>绑定（Tie）指的是：当一个输入流被关联到一个输出流时，任何从输入流读取的操作，都会先自动刷新（flush）那个输出流。<br>默认情况下cin.tie(&amp;cout);每做一次cin之前会执行一次cout.flush();  </p>
<h3 id="8-函数指针"><a href="#8-函数指针" class="headerlink" title="8. 函数指针"></a>8. 函数指针</h3><p>内存区有地方放的数据，一般指针就是指向放数据的地址，但是函数代码其实也会放的，函数指针就是指向函数，可以实现别样的调用函数的方式。<br>回调函数是函数指针最经典的应用。你可以把一个函数作为参数传给另一个函数。最经典的就是sort，cmp函数自定义排序方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明函数指针</span></span><br><span class="line">    <span class="built_in">int</span> (*operation)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向add函数</span></span><br><span class="line">    operation = add;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; <span class="built_in">operation</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 输出7</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向multiply函数</span></span><br><span class="line">    operation = multiply;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3 * 4 = &quot;</span> &lt;&lt; <span class="built_in">operation</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 输出12</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用typedef/using简化</span></span><br><span class="line">    <span class="keyword">using</span> MathFunc = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*newfunc)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line">    newfunc func_new = add;</span><br><span class="line">    MathFunc func = add;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 + 6 = &quot;</span> &lt;&lt; <span class="built_in">func_new</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5 + 6 = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">5</span>, <span class="number">6</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-C-函数新特性-inline对于-define宏函数的替代"><a href="#9-C-函数新特性-inline对于-define宏函数的替代" class="headerlink" title="9.C++函数新特性:inline对于#define宏函数的替代"></a>9.C++函数新特性:inline对于#define宏函数的替代</h3><h3 id="10-引用"><a href="#10-引用" class="headerlink" title="10.引用&amp;"></a>10.引用&amp;</h3><p>引用提供了对变量的别名，相比指针，它必须在声明时就进行初始化，且不能为空，也不能改变指向。在函数传参当中有应用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;ref = x;  <span class="comment">// ref 是 x 的引用（别名）</span></span><br><span class="line"></span><br><span class="line">ref = <span class="number">20</span>;      <span class="comment">// 修改 ref 就是修改 x</span></span><br><span class="line">cout &lt;&lt; x;     <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">ref++;         <span class="comment">// x 变为 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-函数默认参数"><a href="#11-函数默认参数" class="headerlink" title="11.函数默认参数"></a>11.函数默认参数</h3><p>也是一个经常用到的手法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>, <span class="type">int</span> b = <span class="number">2</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="comment">// void func3(int a = 1, int b);  // 错误！默认参数必须在右边</span></span><br><span class="line"><span class="comment">// void func4(int a, int b = 2, int c);  // 错误！c 没有默认值</span></span><br></pre></td></tr></table></figure>
<h3 id="12-函数重载"><a href="#12-函数重载" class="headerlink" title="12.函数重载"></a>12.函数重载</h3><p>也是一个常用的手法，信竞时期我就写大数的加减乘除重载。在执行一些相同操作，但是数据类型不同的情况下，函数重载就派上用场了。  </p>
<h3 id="13-函数模板"><a href="#13-函数模板" class="headerlink" title="13.函数模板"></a>13.函数模板</h3><p>template<typename T>与template<class T>完全等价，现在统一用typename。<br>默认会退化掉引用和 const。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;<span class="comment">//a,b,return 同类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;模板函数: &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改版函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">max</span><span class="params">(T a, U b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的特化版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int重载: &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的不同参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;三个参数的模板: &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(a, b), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5</span>, <span class="number">10</span>) &lt;&lt; endl;      <span class="comment">// 调用 int 重载</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">5.5</span>, <span class="number">10.2</span>) &lt;&lt; endl;  <span class="comment">// 调用模板函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;    <span class="comment">// 调用三个参数的模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-namespace-和-using"><a href="#14-namespace-和-using" class="headerlink" title="14.namespace 和 using"></a>14.namespace 和 using</h3><p>namespace 解决冲突和共存问题。using即为使用。<br>using namespace std;可能会导致很多冲突，特别是全局导入。可以用以下方式代替。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h2><h3 id="1-OOP思想"><a href="#1-OOP思想" class="headerlink" title="1.OOP思想"></a>1.OOP思想</h3><p>相较于面向过程，OOP将数据和行为融合到一起，更符合现实世界中思维，每个对象有数据，也有各种行为。仅仅保留操作的接口，底层数据进行封装，继承多态在我看来主要是代码的复用，一些共有的行为可以继承，一些重复的行为在不同的个体可能有区别。</p>
<h3 id="2-类class"><a href="#2-类class" class="headerlink" title="2.类class"></a>2.类class</h3><p>class默认为private，可以不写。</p>
<h3 id="3-友元"><a href="#3-友元" class="headerlink" title="3.友元"></a>3.友元</h3><p>赋予别的对象对自身private的访问权限。友元不具有传递性，且是单向的（除非两边都有friend）。从宏观设计上来说，如果有些数据本身不应该被提供，就不该写形如getvalue()的接口，而该用友元。只是一些特殊情况要用到，实际上是一直封装起来的。<br>最经典的为cout &lt;&lt;。</p>
<h3 id="4-类和动态内存分配"><a href="#4-类和动态内存分配" class="headerlink" title="4.类和动态内存分配"></a>4.类和动态内存分配</h3><p>问题一：深拷贝与浅拷贝问题，一般而言new与delete是配对的，如果是浅拷贝，两个对象用的同一个地址，delete两次，会出现问题。故而需要深拷贝。即重新写拷贝构造函数而不是用默认的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SafeString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">SafeString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(str);</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="built_in">SafeString</span>(<span class="type">const</span> SafeString&amp; other) &#123;</span><br><span class="line">        length = other.length;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];  <span class="comment">// 分配新内存</span></span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);      <span class="comment">// 复制数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">SafeString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般而言析构函数、拷贝构造函数、赋值运算符重载为Rule of 3，必须同时有。<br>C++11新增了移动构造函数、移动赋值运算符，变为Rule of 5。<br>拷贝会存在性能问题，所谓移动，就是把原来的东西偷过来了，原来就成空壳了。其中noexcept必须要有。否则回退拷贝。</p>
<h3 id="5-类继承"><a href="#5-类继承" class="headerlink" title="5.类继承"></a>5.类继承</h3><p>C++三种继承方式：公有继承、保护继承、私有继承。其中公有继承通常遵循is-a关系（is-a-kind-of）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果不满足is-a关系，公有继承可能会导致一些其他顶层设计问题。<br>公有继承中，父类的private无法访问，其余正常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string accountNumber;  <span class="comment">// 私有，只有本类可以访问</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">double</span> balance;  <span class="comment">// 保护，派生类可以访问，外部不能访问</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">const</span> std::string&amp; accNum, <span class="type">double</span> bal)</span><br><span class="line">        : <span class="built_in">accountNumber</span>(accNum), <span class="built_in">balance</span>(bal) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> balance; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span> : <span class="keyword">public</span> BankAccount &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> interestRate;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SavingsAccount</span>(<span class="type">const</span> std::string&amp; accNum, <span class="type">double</span> bal, <span class="type">double</span> rate)</span><br><span class="line">        : <span class="built_in">BankAccount</span>(accNum, bal), <span class="built_in">interestRate</span>(rate) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addInterest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问基类的保护成员balance</span></span><br><span class="line">        balance += balance * interestRate;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;利息已添加，新余额：&quot;</span> &lt;&lt; balance &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能访问基类的私有成员accountNumber</span></span><br><span class="line">    <span class="comment">// std::string getAccountNumber() &#123; return accountNumber; &#125;  // 错误！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demonstrateProtected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">SavingsAccount <span class="title">sa</span><span class="params">(<span class="string">&quot;123456&quot;</span>, <span class="number">1000.0</span>, <span class="number">0.05</span>)</span></span>;</span><br><span class="line">    sa.<span class="built_in">addInterest</span>();  <span class="comment">// 正确：balance是保护成员，派生类可以访问</span></span><br><span class="line">    <span class="comment">// sa.balance = 2000;  // 错误：保护成员不能在类外访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚函数：多态的重要元素，让函数调用跟着对象真实类型走”，而不是跟着指针类型走。virtual 让编译器延迟到运行时再决定调用谁。<br>父类的析构函数一定为virtual，否则子类在析构时直接调用了父类的析构函数。出现内存泄漏。<br>抽象基类（Abstract Base Class, ABC） 是一个包含至少一个纯虚函数的类。它不能被实例化，主要用于定义接口和创建派生类的通用框架。<br>它是“概念层接口”，不是“实现层类”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;   <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>派生类必须实现所有的纯虚函数。</p>
<h3 id="6-C-中的代码重用"><a href="#6-C-中的代码重用" class="headerlink" title="6.C++中的代码重用"></a>6.C++中的代码重用</h3><p>私有继承：是由基类实现的，但并不属于基类那一类。基类中public和protected均变为private，基类中private依旧不可访问，<br>不保持接口继承，不实现向上转型，可以重新公开基类成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Engine started\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">private</span> Engine &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">start</span>();  <span class="comment">// 内部使用Engine功能</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Car is moving\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    car.<span class="built_in">drive</span>();</span><br><span class="line">    <span class="comment">// car.start();  // 错误: start()在Car中是私有的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 错误: 私有继承不允许隐式向上转型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用using重新公开特定成员</span></span><br><span class="line">    <span class="keyword">using</span> Base::publicFunc;  <span class="comment">// 将publicFunc恢复为public访问权限</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 或通过包装函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">exposedFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Base::<span class="built_in">publicFunc</span>();  <span class="comment">// 转发调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而组合在C++中更为常见。但组合无法访问protected</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Engine engine;   <span class="comment">// 组合</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>保护继承：私有继承一个变体，基类中protected和private都变为protected。<br>多重继承，字面意思。会有一个经典问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 菱形继承示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Animal eating\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Mammal breathing\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bird flying\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echolocate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bat echolocating\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题：Bat中有两个Animal子对象</span></span><br><span class="line"><span class="comment">内存布局：</span></span><br><span class="line"><span class="comment">Bat对象 &#123;</span></span><br><span class="line"><span class="comment">    Mammal部分 &#123;</span></span><br><span class="line"><span class="comment">        Animal部分 &#123; age &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Bird部分 &#123;</span></span><br><span class="line"><span class="comment">        Animal部分 &#123; age &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bat bat;</span><br><span class="line">    <span class="comment">// bat.age = 5;          // 错误：不明确，有两个age</span></span><br><span class="line">    bat.Mammal::age = <span class="number">5</span>;    <span class="comment">// 明确指定</span></span><br><span class="line">    bat.Bird::age = <span class="number">3</span>;      <span class="comment">// 另一个age</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bat.eat();           // 错误：不明确</span></span><br><span class="line">    bat.Mammal::<span class="built_in">eat</span>();      <span class="comment">// 明确指定</span></span><br><span class="line">    bat.Bird::<span class="built_in">eat</span>();        <span class="comment">// 另一个eat()</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Mammal age: &quot;</span> &lt;&lt; bat.Mammal::age &lt;&lt; endl;  <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bird age: &quot;</span> &lt;&lt; bat.Bird::age &lt;&lt; endl;      <span class="comment">// 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在解决方面采用虚继承。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Animal eating\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mammal</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;  <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Mammal breathing\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;    <span class="comment">// 虚继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bird flying\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bat</span> : <span class="keyword">public</span> Mammal, <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">echolocate</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Bat echolocating\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="7-类模板"><a href="#7-类模板" class="headerlink" title="7.类模板"></a>7.类模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T content;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(T item) : <span class="built_in">content</span>(item) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getContent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> content; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setContent</span><span class="params">(T item)</span> </span>&#123; content = item; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Box&lt;T&gt;::<span class="built_in">setContent</span>(T item) &#123;</span><br><span class="line">    content = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>依旧是在数据类型不确定的情况下使用模板类。</p>
<h3 id="8-友元、异常和其他"><a href="#8-友元、异常和其他" class="headerlink" title="8.友元、异常和其他"></a>8.友元、异常和其他</h3><p>C++异常处理通常有</p>
<ul>
<li>try:放可能出错的代码</li>
<li>throw:抛出异常</li>
<li>catch:捕获并处理<br>最佳是抛出类对象，C++ 提供了一系列预定义的异常类，也可通过类继承来自定义异常类。<br>栈解退（Stack Unwinding） 是C++异常处理机制中的一个核心过程，指在异常抛出时，系统自动从当前抛出点开始，沿着调用链逐层回溯，并在离开每个函数作用域时自动调用该函数中所有局部对象的析构函数的过程。</li>
</ul>
<h3 id="9-RTTI"><a href="#9-RTTI" class="headerlink" title="9.RTTI"></a>9.RTTI</h3><p>RTTI是 C++ 的一种机制，允许程序在运行阶段确定对象的具体类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line">Base* b = <span class="keyword">new</span> Derived;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(*b).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 Derived</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于安全地进行向下转型（downcasting）和横向转型（cross-casting），在类型不匹配时返回 nullptr（对于指针）或抛出异常（对于引用）</span></span><br><span class="line">Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br><span class="line"><span class="keyword">if</span> (d) &#123; <span class="comment">/* 转型成功 */</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-类型转换运算符"><a href="#10-类型转换运算符" class="headerlink" title="10.类型转换运算符"></a>10.类型转换运算符</h3><ul>
<li>static_cast：它不进行运行时的类型检查（RTTI），在类型层次关系确定、没有涉及运行时检查的情况下进行转换。</li>
<li>dynamic_cast：主要用于 多态类型（含虚函数的类）指针或引用的安全向下转换。它进行运行时的类型检查（RTTI），要求基类必须至少包含一个虚函数（否则无法启用 RTTI 机制）。</li>
<li>const_cast：常用于去掉或添加 const，但不改变对象本身类型。</li>
<li>reinterpret_cast：进行低级别的、不安全的指针类型或整数类型转换。</li>
</ul>
<h3 id="11-智能指针"><a href="#11-智能指针" class="headerlink" title="11.智能指针"></a>11.智能指针</h3><p>对于new和delete配对的情况，常常会出现没有delete而导致的内存泄漏，程序抛出异常导致 delete 语句被跳过。多个指针指向同一内存，其中一个释放了，其他指针变成了野指针。<br>针对这个情况，有智能指针的出现：<br>C++98版本为 auto_ptr，在C++11,auto_ptr被移除，有unique_ptr、shared_ptr、weak_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;<span class="type">int</span>&gt; b = a; <span class="comment">// 所有权转移</span></span><br></pre></td></tr></table></figure>
<p>现在 a 不再拥有对象，指向 nullptr。如果不注意，会引起悬空指针或重复释放的风险,容易和普通指针混淆，违反“拷贝不改变原对象”的直觉。<br>由于 auto_ptr 的这种特殊拷贝行为，它完全无法在 STL 容器（如 vector）中使用。</p>
<ol>
<li>std::unique_ptr<br>独占资源，不存在两个unique_ptr指向同一个内存。只能移动不能拷贝</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl;  <span class="comment">// 像普通指针一样使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转移所有权</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = std::<span class="built_in">move</span>(ptr); </span><br><span class="line"><span class="keyword">if</span> (!ptr) std::cout &lt;&lt; <span class="string">&quot;ptr 已为空&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>std::shared_ptr<br>共享资源：可以多个 shared_ptr 拥有同一个对象。内部维护 引用计数，最后一个 shared_ptr 被销毁时释放对象。支持拷贝和移动。<br>需要注意循环引用问题，否则内存不会释放。如果 A 指向 B，B 又指向 A，会导致内存泄漏。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;  <span class="comment">// 引用计数增加</span></span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">50</span>);</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sp2 = sp1;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">sp<span class="number">2.</span><span class="built_in">reset</span>();  <span class="comment">// 释放 sp2 对象，引用计数减 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; sp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>std::weak_ptr<br>它是 shared_ptr 的辅助工具，用来解决循环引用问题。它指向 shared_ptr 管理的内存，但不增加引用计数。它不能直接访问对象，必须先通过 lock() 方法“提升”为 shared_ptr。</li>
</ol>
<h3 id="12-STL"><a href="#12-STL" class="headerlink" title="12.STL"></a>12.STL</h3><p>容器（顺序容器、关联容器、无序容器、容器适配器）、算法（如sort）、迭代器。<br>C++的迭代器包括输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。<br>函数对象：顾名思义，像函数一样调用的对象，STL 内置仿函数。最经典为sort排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); </span><br><span class="line"><span class="comment">// 结果: 5, 4, 3, 1</span></span><br></pre></td></tr></table></figure>
<p>STL算法：作用于迭代器区间的函数模板，例如sort、binary_search、lower_bound</p>
<h3 id="13-常见STL的使用"><a href="#13-常见STL的使用" class="headerlink" title="13.常见STL的使用"></a>13.常见STL的使用</h3><p>具体使用方面网上也比较多资源，这里给一个链接：<a target="_blank" rel="noopener" href="https://io.zouht.com/154.html">https://io.zouht.com/154.html</a><br>vector、（string）、map、set、queue</p>
<ol>
<li>vector<br>vector的使用应当初始就给定一个比较确定的长度，防止其重分配消耗大量时间。<br>在信息竞赛方面需要当心size_t的溢出</li>
<li>stack和queue<br>没啥好说的</li>
<li>priority_queue<br>提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。<br>这里恶补一下堆。堆只能是完全二叉树。<br>大根堆：父节点元素必须大于他的子节点元素。<br>小根堆：与大根堆相反。<br>堆的储存，父节点下标为i，左子节点下标为2i+1，右为2i+2。<br>堆的基本操作：上滤、下滤。<br>下滤：根节点往子节点走（交换为满足堆序性）。<br>上滤：与下滤类似。<br>建堆方法：自顶向下、自底向上。<br>优先队列：小根堆的根节点就是最小的，弹出即可。弹出后将最后一个元素放到根上进行下滤即可维护堆。堆排序就是一直弹出一直维护的过程。  </li>
<li>set<br>set基于红黑树。set的特点是去重、有序。set 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念<br>红黑树是二叉搜索树（左&lt;根&lt;右）。在这个基础上引入红色黑色。根节点和叶子节点（NULL空节点，可能插入新值的地方）都是黑色。所有红色节点左右子节点必须是黑色，即没有两个连续红色节点，任一节点到叶子节点所有路径上的黑色节点数量都是相同的。</li>
</ol>
<p><code>左根右，根叶黑，不红红，黑路同</code><br>最长路径不超过最短路径的两倍。<br>插入节点默认为红色。</p>
<ul>
<li>插入结点是根节点：直接变黑</li>
<li>插入结点的叔叔是红色：叔父爷变色，跳转到爷爷处继续判定。</li>
<li>插入节点的叔叔是黑色：（LL,RR,LR,RL）旋转，然后变色。<br>其中得再看下<strong>平衡树</strong>相关内容。</li>
</ul>
<ol start="5">
<li>map<br>map的底层原理是红黑树，提供对数时间的有序键值对结构。</li>
</ol>
<p><code>map&lt;键类型, 值类型, 比较器&gt; mp</code><br>6. string<br>string 的 +&#x3D; 运算符，将会在原字符串原地尾接字符串。而 + 了再 &#x3D; 赋值，会先生成一个临时变量，在复制给 string.<br>.find()查找子串方法是n方暴力实现。<br>7. pair<br>二元组</p>
<h2 id="现代C"><a href="#现代C" class="headerlink" title="现代C++"></a>现代C++</h2><ol>
<li>modern C++的内存管理，std::unique_ptr等智能指针代替new&#x2F;delete</li>
<li>push_back往往需要先创建一个临时对象，然后将其拷贝或移动到容器中。而 emplace_back 直接在容器的内存空间中调用构造函数，省去了临时对象的创建、拷贝和析构过程，效率更高。</li>
<li>Rule of 0,在现代 C++ 中，通过使用智能指针和标准库容器（如 std::vector, std::string），这些组件已经处理好了所有的资源管理。因此，你的类不需要手动定义任何特殊的成员函数，编译器会自动生成正确的默认行为。这极大减少了维护负担。</li>
<li>std::endl 除了输出换行符外，还会强制执行 flush（刷新输出缓冲区）。在处理大量数据流时，频繁刷新会显著降低 I&#x2F;O 性能。如果你只是单纯想换行，使用 \n 就足够了。更好可以使用std::println()</li>
</ol>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p>默认情况下，auto 会剥离掉表达式的顶层 const 和 引用（&amp;）属性。<br>auto&amp;是左值引用（别名），可以保留顶层的const。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>; <span class="keyword">auto</span> x = &amp;a;<span class="comment">//指向常量的指针，推导为const int*</span></span><br></pre></td></tr></table></figure>
<p>右值引用（Rvalue Reference）是 C++11 引入的一种新引用类型，专门用来“捕捉”那些即将销毁的临时对象（右值）。<br>左值 (Lvalue)：有名字、有固定内存地址的对象。例如：变量名、返回引用的函数调用。<br>右值 (Rvalue)：匿名的、临时的、没有固定地址的对象。例如：字面量（10, true）、临时表达式的结果（x + y）、返回非引用的函数返回值。<br>在旧版 C++ 中，临时对象在传递时必须经过“拷贝”。如果这个对象很大（比如一个含有 100 万个元素的 vector），这种拷贝会严重拖慢性能。右值引用的出现是为了实现“移动语义 (Move Semantics)”： 它允许我们直接“偷取”临时对象的资源，而不是重新复制一份。<br>auto&amp;&amp; 万能引用,左值引用右值引用均可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; d = x;  <span class="comment">// x 是左值，所以 d 是 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; e = <span class="number">10</span>; <span class="comment">// 10 是右值，所以 e 是 int&amp;&amp;（合法！）</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>写法</th>
<th>推导结果</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>const int a = 10; auto x = a;</code></td>
<td><code>int</code></td>
<td>顶层 const 被丢弃</td>
</tr>
<tr>
<td><code>const int a = 10; auto&amp; x = a;</code></td>
<td><code>const int&amp;</code></td>
<td>引用保留 const</td>
</tr>
<tr>
<td><code>auto x = &amp;a;</code></td>
<td><code>const int*</code></td>
<td>底层 const 保留</td>
</tr>
<tr>
<td><code>auto&amp;&amp; x = a;</code></td>
<td><code>int&amp;</code></td>
<td>万能引用折叠</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// x = std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> y&#123;<span class="number">1</span>&#125;;        <span class="comment">// int</span></span><br><span class="line"><span class="keyword">auto</span> z = &#123;<span class="number">1</span>&#125;;     <span class="comment">// std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span> <span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(<span class="keyword">auto</span> a,<span class="keyword">auto</span> b)</span></span>&#123;<span class="comment">//C++20形参也可auto</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++14中lambda表达式的形参可以用auto</span></span><br><span class="line"><span class="keyword">auto</span> sum = [](<span class="keyword">auto</span> a,<span class="keyword">auto</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="keyword">auto</span> ans = <span class="built_in">sum</span>(<span class="number">5.2</span>,<span class="number">2.4</span>);</span><br><span class="line">std::cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++17</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; N &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="number">10</span>&gt;();    <span class="comment">// N 被推导为 int</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="string">&#x27;A&#x27;</span>&gt;();   <span class="comment">// N 被推导为 char</span></span><br><span class="line">    <span class="built_in">f</span>&lt;<span class="literal">true</span>&gt;();  <span class="comment">// N 被推导为 bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问题杂谈</strong>：明明编译没问题，但是vscode界面报一堆错，很明显就是C&#x2F;C++的插件还在用老标准如C++98，这里找到对应插件，更改Cpp Standard即可。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>建议使用std::make_unique(C++14)。<br>当你使用 new 时，你在堆上申请了一块空间，并返回一个指向该空间的原始指针存储在栈上。<br>智能指针利用了 RAII (Resource Acquisition Is Initialization) 核心思想：将堆内存的生命周期绑定到栈对象的生命周期上。<br>shared_ptr本质是两个指针组成的：</p>
<ul>
<li>ptr1：指向持有的资源对象</li>
<li>ptr2：指向一个控制块。<br>控制块里面有：强引用计数（shared_ptr）、弱引用计数（weak_ptr）、自定义删除器（如果用户提供了自定义的销毁逻辑）、分配器（用以管理控制块自身的内存）。<br>shared_ptr的引用技术增减是原子操作因此在多线程环境下增加或减少引用计数是线程安全的。<br>shared_ptr 指向的对象本身不是线程安全的。如果你多个线程通过 shared_ptr 同时修改同一个对象，依然需要加锁（如 std::mutex）。<br>在性能开销层面：<br>每次拷贝或销毁 shared_ptr 都会涉及原子指令，这比普通的加减法慢得多。<br>需要额外分配控制块内存。如果你用 new 创建对象再传给 shared_ptr，会发生两次内存分配（对象一次，控制块一次）。<br>使用 std::make_shared。它会一次性申请一块连续内存同时存放对象和控制块，效率更高且内存碎片更少。<br>weak_ptr如何知道对象被释放：<br>shared_ptr 销毁的条件是“强引用计数 &#x3D; 0”。此时，对象会被析构，但控制块不会立即销毁。<br>只有当“强引用计数 &#x3D; 0”且“弱引用计数 &#x3D; 0”时，控制块才会被从堆上释放。<br>weak_ptr 通过查看控制块中的强引用计数是否大于 0 来判断对象是否还有效。当你调用 lock() 时，它会检查强引用计数，如果大于 0，就返回一个新的 shared_ptr。</li>
</ul>
<h3 id="移动语义与右值引用"><a href="#移动语义与右值引用" class="headerlink" title="移动语义与右值引用"></a>移动语义与右值引用</h3><p>在C++11以前，对象只能深拷贝，但这在处理大型容器或临时对象时会导致巨大的性能开销。**移动语义（Move Semantics）**的引入，实质上是为了解决“不必要的拷贝”问题，让程序能够“夺取”临时对象的资源。<br>移动语义的核心在于资源转移，跟拷贝的区别也就是移动与复制的区别。<br>在C++类中，关键内容就是移动构造函数和移动赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(Vector&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">        : <span class="built_in">data</span>(other.data), <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;  <span class="comment">// 源对象放弃所有权</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>=(Vector&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;        <span class="comment">// 释放当前资源</span></span><br><span class="line">            data = other.data;    <span class="comment">// 接管资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>; <span class="comment">// 源对象置空</span></span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>std::move也是一个常用的函数，将左值转换为右值。<br>完美转发与万能引用：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123;  <span class="comment">// 通用引用：T&amp;&amp;</span></span><br><span class="line">    <span class="comment">// 保持arg的值类别（左值/右值）</span></span><br><span class="line">    <span class="comment">// std::forward&lt;T&gt;(arg) 会根据 T 的实际类型进行转发</span></span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetConsoleOutputCP</span>(<span class="number">65001</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(a);           <span class="comment">// 调用process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">20</span>);          <span class="comment">// 调用process(int&amp;&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// 调用process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Lambda 是 匿名函数，可以在代码中“就地定义、就地使用”的小函数。<br>C++14后参数可以使用auto</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用 Lambda 按降序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : nums)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[]是捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f1 = [a]() &#123; cout &lt;&lt; a; &#125;;     <span class="comment">// 值捕获</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;a]() &#123; a++; &#125;;          <span class="comment">// 引用捕获</span></span><br></pre></td></tr></table></figure>
<p>值捕获默认是const，如果要修改捕获变量，则需要mutable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [x]() <span class="keyword">mutable</span> &#123; x++; &#125;;</span><br></pre></td></tr></table></figure>
<p>C++14有初始化捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> lambda = [p = std::<span class="built_in">move</span>(ptr)]() &#123; <span class="comment">/* 使用 p */</span> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++20支持模板参数列表</span></span><br><span class="line">    <span class="keyword">auto</span> add = []&lt;<span class="keyword">typename</span> T&gt;(T a, T b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3.0</span>,<span class="number">4.1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//注意类型必须一致，如果写3，则会报错。</span></span><br><span class="line">    <span class="comment">// 等价于C++14的auto参数，但更明确</span></span><br></pre></td></tr></table></figure>
<h3 id="并发与多线程"><a href="#并发与多线程" class="headerlink" title="并发与多线程"></a>并发与多线程</h3><ol>
<li>初级<br>std::thread创建进程。<br>当多个线程同时访问同一块内存（数据竞争）时，会导致不可预知的错误。因为有些操作并不是原子操作，比如a++,需要放到寄存器中，加了再放回内存，会被打断。<br>std::mutex是C++最基本的互斥锁。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 方法1：手动锁定/解锁</span></span><br><span class="line">        mtx.<span class="built_in">lock</span>();</span><br><span class="line">        ++shared_data;</span><br><span class="line">        mtx.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法2：使用lock_guard（推荐）</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lock(mtx);</span></span><br><span class="line">        <span class="comment">// ++shared_data;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法3：使用unique_lock（更灵活）</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lock(mtx);</span></span><br><span class="line">        <span class="comment">// ++shared_data;</span></span><br><span class="line">        <span class="comment">// lock.unlock(); // 可提前解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment, <span class="number">100000</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment, <span class="number">100000</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Final value: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动解锁容易出错（如遇到异常导致未解锁），建议使用 RAII 包装类,如lock_guard和unique_lock。<br>lock_guard符合 RAII 编程范式：构造时自动加锁，析构时（即离开大括号作用域时）自动解锁。<br>unique_lock是lock_guard的升级，可以中途解锁。<br>std::condition_variable::wait 的工作原理是：<br>释放锁并让线程进入休眠（原子操作），被唤醒后，重新获取锁。必须使用unique_lock。  </p>
<ul>
<li>条件变量<br>Wait 与 Notify</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; data_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            data_queue.<span class="built_in">push</span>(i);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;生产: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.<span class="built_in">notify_one</span>(); <span class="comment">// 发送信号：数据准备好了</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">// wait 内部会：1.释放锁 -&gt; 2.等待通知 -&gt; 3.拿到通知后重新获取锁 -&gt; 4.检查 lambda 表达式</span></span><br><span class="line">        <span class="comment">//一定不能写如下代码，要不然的话有可能会死锁，也有可能出现虚假唤醒，靠通知是不靠谱的，一定还要检测状态。</span></span><br><span class="line">        <span class="comment">//cv.wait(lock); </span></span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>(); &#125;); </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;消费: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(producer)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(consumer)</span></span>;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，假设producer先拿到锁，然后计算完了，那之前consumer就卡在了std::unique_lock<a href="std::mutex">std::mutex</a> lock(mtx);那发送的cv.notify_one();也就没用，因为还没进去wait吗，但是wait是会先进行判断的，条件符合不会进行等待的。实测如果是std::wait(lock);真的会一直等待。  </p>
<ul>
<li>读写锁<br>C++17引入了一个读写锁，对于读取操作，显然是可以让多个线程同时获取共享数据的，而互斥锁就难以实现这个需求，读写锁就是为了解决这个问题。<br>读模式（共享）：只要没有线程在写，多个线程可以同时获取读锁。<br>写模式（独占）：只要有一个线程在写，其他线程既不能读也不能写。<br>只要有写线程在排队，读线程就得排在写线程后面，防止一直写不上。<br>可以与shared_ptr和unique_ptr类比。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, std::string&gt; config_data;</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex rw_mtx; <span class="comment">// 读写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 读操作：使用 shared_lock，允许多人同时读</span></span><br><span class="line">    <span class="function">std::string <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is reading...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> config_data.<span class="built_in">count</span>(key) ? config_data.<span class="built_in">at</span>(key) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作：使用 unique_lock，完全独占</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(rw_mtx)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; is WRITING!!!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        config_data[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>原子操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        counter++; <span class="comment">// 原子操作，线程安全，且不需要锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) threads.<span class="built_in">emplace_back</span>(increment);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl; <span class="comment">// 始终是 10000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步编程<br>异步编程（Asynchronous Programming） 的核心思想是：发出一个任务指令后立即返回，让任务在后台运行，而主线程可以继续执行其他工作。 当我们需要结果时，再去“领取”。</li>
<li>最简易异步编程std::async与std::future</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fetchDataFromDB</span><span class="params">(std::string query)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>)); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 异步启动任务</span></span><br><span class="line">    <span class="comment">// std::launch::async 确保在新线程中运行</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(std::launch::async, fetchDataFromDB, <span class="string">&quot;SELECT...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;主线程正在做其他事...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在需要的时候获取结果</span></span><br><span class="line">    <span class="type">int</span> val = result.<span class="built_in">get</span>(); <span class="comment">// 如果 fetchDataFromDB 还没完，这里会等它</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数据库返回: &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>std::promise&#x2F;std::future<br>std::promise是C++11并发编程中常用的一个类，常配合std::future使用。其作用是在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread_Fun1</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//为了突出效果，可以使线程休眠5s</span></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> iVal = <span class="number">233</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;传入数据(int)：&quot;</span> &lt;&lt; iVal &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//传入数据iVal</span></span><br><span class="line">	p.<span class="built_in">set_value</span>(iVal);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread_Fun2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt; &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//阻塞函数，直到收到相关联的std::promise对象传入的数据</span></span><br><span class="line">	<span class="keyword">auto</span> iVal = f.<span class="built_in">get</span>();		<span class="comment">//iVal = 233</span></span><br><span class="line"> </span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;收到数据(int)：&quot;</span> &lt;&lt; iVal &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//声明一个std::promise对象pr1，其保存的值类型为int</span></span><br><span class="line">	std::promise&lt;<span class="type">int</span>&gt; pr1;</span><br><span class="line">	<span class="comment">//声明一个std::future对象fu1，并通过std::promise的get_future()函数与pr1绑定</span></span><br><span class="line">	std::future&lt;<span class="type">int</span>&gt; fu1 = pr<span class="number">1.</span><span class="built_in">get_future</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//创建一个线程t1，将函数Thread_Fun1及对象pr1放在线程里面执行</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(Thread_Fun1, std::ref(pr1))</span></span>;</span><br><span class="line">	<span class="comment">//创建一个线程t2，将函数Thread_Fun2及对象fu1放在线程里面执行</span></span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(Thread_Fun2, std::ref(fu1))</span></span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//阻塞至线程结束</span></span><br><span class="line">	t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">	t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C++20协程<br>可以暂停执行并在稍后恢复的函数。在函数执行中途将CPU资源让给别人。<br>co_await <expr>：暂停当前协程，直到等待的任务完成。</li>
</ul>
<p>co_return <expr>：从协程返回一个值并结束协程。</p>
<p>co_yield <expr>：暂停协程并返回一个值给调用者（常用于生成器&#x2F;迭代器）。</p>
<ul>
<li>线程池<br>频繁地创建和销毁线程（std::thread）开销很大，因为这涉及到操作系统内核的系统调用。线程池通过预先创建一组固定数量的线程并让它们保持存活，通过一个任务队列来循环处理不断到来的任务，从而提高性能。<br>CPU 密集型任务（如复杂计算）：建议线程数 &#x3D; CPU 核心数。多出的线程只会增加上下文切换的开销。<br>IO 密集型任务（如网络请求、读写磁盘）：建议线程数 &#x3D; CPU 核心数 * 2 或更多。因为线程经常在等待 IO，多开线程可以充分利用 CPU 空闲时间。</li>
</ul>
<h3 id="范围for循环"><a href="#范围for循环" class="headerlink" title="范围for循环"></a>范围for循环</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (声明 : 范围表达式) &#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v) </span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;x : v)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;x : v)</span><br><span class="line">        x *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">        std::cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : v1) </span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x : v1)</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好用const auto简单好用。注意不要在循环体内改变容器的大小</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>将计算从运行期转移到编译期。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;sz);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = sz;          <span class="comment">// 正确：a 是只读的，但值在运行时确定</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = sz;      <span class="comment">// 错误：sz 的值在编译时未知，编译失败</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> c = <span class="number">42</span>;      <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>C++11只能一条return，C++14可以用if，for等，C++17可以使用constexpr lambda</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> f = [](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>decltype<br>在编译期推导表达式的类型，但并不实际计算表达式的值。auto推导会丢引用，大部分情况也会丢const,而decltype不会。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a = <span class="number">10</span>;   <span class="comment">// a 的类型是 const int</span></span><br><span class="line"><span class="type">int</span>&amp; j = a;</span><br><span class="line"><span class="keyword">decltype</span>(j) b = a;   <span class="comment">// b 的类型是 int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_int</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">get_int</span>()) x; <span class="comment">// x 的类型是 int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i)   a; <span class="comment">// int (变量名)</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b = i; <span class="comment">// int&amp; (带括号的表达式，i 是左值，所以推导为引用)</span></span><br></pre></td></tr></table></figure>
<p>C++14 引入了 decltype(auto)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">get_ref</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">get_ref</span>();          <span class="comment">// a 是 int（副本）</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) b = <span class="built_in">get_ref</span>(); <span class="comment">// b 是 int&amp;（真正的引用）</span></span><br></pre></td></tr></table></figure>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ol>
<li>C++内存布局全貌。这个自我感觉比较偏底层，差不多是汇编那个层面。有代码段、数据段、BSS段、栈、堆。</li>
<li>make,cmake,makefile<br>CMake 用来“生成 Makefile”，Make 用来“执行 Makefile”，Makefile 是“构建规则本身”</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最终目标：生成 app</span></span><br><span class="line"><span class="section">app: main.o tool.o</span></span><br><span class="line">	gcc -o app main.o tool.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间环节：如何生成 main.o</span></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">	gcc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中间环节：如何生成 tool.o</span></span><br><span class="line"><span class="section">tool.o: tool.c</span></span><br><span class="line">	gcc -c tool.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标：清理编译产生的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o app</span><br></pre></td></tr></table></figure>
<p>之前在windows上使用cmake有很多问题，cmake后我发现未生成makefile文件，后续发现是因为默认使用MSVC编译器导致的，要解决可以加一句cmake -G “MinGW Makefiles”。<br>然后就是找不到make指令，需要用mingw32-make。好像用cmake –build也行</p>

    </div>
    <footer class="article-footer">
      
      
    </footer>
  </div>
    <nav id="article-nav" aria-label="Article navigation" data-aos="fade-up">
      <div class="article-nav-link-wrap left">
            <img data-src="/covers/bg6.webp" data-sizes="auto" alt="Hexo+github pages构建个人博客" class="lazyload">
        <a href="/2026/01/18/Hexo+github%20pages%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" aria-label="前一篇: Hexo+github pages构建个人博客" title="前一篇: Hexo+github pages构建个人博客"></a>
        <div class="article-nav-caption">前一篇</div>
        <h3 class="article-nav-title">
            Hexo+github pages构建个人博客
        </h3>
      </div>
  </nav>

</article>


</section>
        </div>
        <footer id="footer" aria-label="Site footer">
  <div style="width: 100%; overflow: hidden">
    <div class="footer-line"></div>
  </div>
  <div id="footer-info">
    <div>
      <span class="icon-copyright"></span>
        2020-2026
        <span class="footer-info-sep rotate"></span>
      Sanae
    </div>
      <div>
        基于&nbsp;<a href="https://hexo.io/" rel="noopener nofollow noreferrer" target="_blank">Hexo</a>&nbsp;
        Theme.<a href="https://github.com/D-Sketon/hexo-theme-reimu" rel="noopener nofollow noreferrer" target="_blank">Reimu</a>
      </div>
      <div>
        <span class="icon-brush"></span>
        10.2k
        &nbsp;|&nbsp;
        <span class="icon-coffee"></span>
        00:45
      </div>
      <div>
        <span class="icon-eye"></span>
        <span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span>
        &nbsp;|&nbsp;
        <span class="icon-user"></span>
        <span id="busuanzi_container_site_uv">总访客量&nbsp;<span id="busuanzi_value_site_uv"></span></span>
      </div>
  </div>
</footer>

          <div class="sidebar-top">
            <div class="sidebar-top-taichi rotate"></div>
            <div class="arrow-up"></div>
          </div>
        <div id="mask" class="hide"></div>
      </div>
      <nav id="mobile-nav" aria-label="Mobile navigation">
  <div class="sidebar-wrap">
        <div class="sidebar-toc-sidebar"><h3 class="toc-title">文章目录</h3>
<div class="sidebar-toc-wrapper toc-div-class" >
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">C++基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-iostream-%E5%92%8Cusing-namespace-std"><span class="toc-number">1.1.</span> <span class="toc-text">1.iostream 和using namespace std;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-cin-getline-%E5%92%8C-cin-get-%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">2.cin.getline() 和 cin.get()读入字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8C%87%E9%92%88%E3%80%81new%E3%80%81delete"><span class="toc-number">1.3.</span> <span class="toc-text">3.指针、new、delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-typedef-%E5%88%AB%E5%90%8D"><span class="toc-number">1.4.</span> <span class="toc-text">4.typedef 别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-number">1.5.</span> <span class="toc-text">5.小插曲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-11%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.</span> <span class="toc-text">6.C++11基于范围的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-cin-cout%E5%AF%B9%E6%AF%94scanf-printf"><span class="toc-number">1.7.</span> <span class="toc-text">7.cin&#x2F;cout对比scanf&#x2F;printf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.8.</span> <span class="toc-text">8. 函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-C-%E5%87%BD%E6%95%B0%E6%96%B0%E7%89%B9%E6%80%A7-inline%E5%AF%B9%E4%BA%8E-define%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E6%9B%BF%E4%BB%A3"><span class="toc-number">1.9.</span> <span class="toc-text">9.C++函数新特性:inline对于#define宏函数的替代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%BC%95%E7%94%A8"><span class="toc-number">1.10.</span> <span class="toc-text">10.引用&amp;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">11.函数默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.</span> <span class="toc-text">12.函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.13.</span> <span class="toc-text">13.函数模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-namespace-%E5%92%8C-using"><span class="toc-number">1.14.</span> <span class="toc-text">14.namespace 和 using</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOP"><span class="toc-number">2.</span> <span class="toc-text">OOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-OOP%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">1.OOP思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BBclass"><span class="toc-number">2.2.</span> <span class="toc-text">2.类class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%8B%E5%85%83"><span class="toc-number">2.3.</span> <span class="toc-text">3.友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.4.</span> <span class="toc-text">4.类和动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">5.类继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-number">2.6.</span> <span class="toc-text">6.C++中的代码重用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.7.</span> <span class="toc-text">7.类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%8F%8B%E5%85%83%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96"><span class="toc-number">2.8.</span> <span class="toc-text">8.友元、异常和其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-RTTI"><span class="toc-number">2.9.</span> <span class="toc-text">9.RTTI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.10.</span> <span class="toc-text">10.类型转换运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.11.</span> <span class="toc-text">11.智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-STL"><span class="toc-number">2.12.</span> <span class="toc-text">12.STL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%B8%B8%E8%A7%81STL%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.13.</span> <span class="toc-text">13.常见STL的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3C"><span class="toc-number">3.</span> <span class="toc-text">现代C++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto"><span class="toc-number">3.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">移动语义与右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">并发与多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4for%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.6.</span> <span class="toc-text">范围for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr"><span class="toc-number">3.7.</span> <span class="toc-text">constexpr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">杂项</span></a></li></ol>
</div>
</div>
        <div class="sidebar-common-sidebar hidden"><div class="sidebar-author">
  <img data-src="/avatar/avatar.jpg" data-sizes="auto" alt="Sanae" class="lazyload">
  <div class="sidebar-author-name">Sanae</div>
  <div class="sidebar-description"></div>
</div>
<div class="sidebar-state">
  <div class="sidebar-state-article">
    <div>文章</div>
    <div class="sidebar-state-number">2</div>
  </div>
  <div class="sidebar-state-category">
    <div>分类</div>
    <div class="sidebar-state-number">0</div>
  </div>
  <div class="sidebar-state-tag">
    <div>标签</div>
    <div class="sidebar-state-number">0</div>
  </div>
</div>
<div class="sidebar-social" >
</div>
<div class="sidebar-menu">
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/" aria-label="首页"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">首页</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/archives" aria-label="归档"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">归档</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/about" aria-label="关于"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">关于</div>
      </div>
      <div class="sidebar-menu-link-wrap">
        <a class="sidebar-menu-link-dummy" href="/friend" aria-label="友链"></a>
          <div class="sidebar-menu-icon icon rotate">
              &#xe62b;
          </div>
        <div class="sidebar-menu-link">友链</div>
      </div>
</div>
</div>
  </div>
      <div class="sidebar-btn-wrapper">
        <div class="sidebar-toc-btn current"></div>
        <div class="sidebar-common-btn"></div>
      </div>
</nav>

    </div>
    
<script src="https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js" integrity="sha384-3gT&#x2F;vsepWkfz&#x2F;ff7PpWNUeMzeWoH3cDhm&#x2F;A8jM7ouoAK0&#x2F;fP&#x2F;9bcHHR5kHq2nf+e" crossorigin="anonymous"></script>


<script src="https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js" integrity="sha384-J08i8An&#x2F;QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


  
<script src="/js/aos.js"></script>

  <script>
    var aosInit = () => {
      AOS.init({
        duration: 1000,
        easing: "ease",
        once: true,
        offset: 50,
      });
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', aosInit);
    } else {
      aosInit();
    }
  </script>


<script src="/js/pjax_script.js" data-pjax></script>




  <script>
    var setupFirework = () => {
      if (!false || !window.matchMedia('(max-width: 768px)').matches) {
        window.firework && window.firework(JSON.parse('{"excludeElements":["a","button"],"particles":[{"shape":"circle","move":["emit"],"easing":"easeOutExpo","colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"number":20,"duration":[1200,1800],"shapeOptions":{"radius":[16,32],"alpha":[0.3,0.5]}},{"shape":"circle","move":["diffuse"],"easing":"easeOutExpo","colors":["var(--red-0)"],"number":1,"duration":[1200,1800],"shapeOptions":{"radius":20,"alpha":[0.2,0.5],"lineWidth":6}}]}'));
      }
    }
  </script>
  
<script src="https://npm.webcache.cn/mouse-firework@0.2.0/dist/index.umd.js" integrity="sha384-qi9WggRt19tv8Vc7pCHW3ulMNLwrn515zaLEWZjl1px07vz8+pUoWX8n1rgq282T" crossorigin="anonymous" onload="setupFirework()" defer></script>






<div id="lazy-script">
  <div>
      
      
      <script data-pjax>
        window.REIMU_POST = {
          author: "Sanae",
          title: "C++ primer plus review",
          url: "http://example.com/2026/01/18/review/",
          excerpt: "",
          description: "",
          stripContent: "C++基础1.iostream 和using namespace std;看源码，iostream包含了C++中io的对象（不是函数），最常用的为cin，cout，在std命名空间。std 命名空间包含了C++标准库中所有的标识符 1234567891011121314// 命名冲突示例#include &amp;lt;iostream&amp;gt;using namespace std;// 假设我们自己定义了一个 count 函数int count() &amp;#123;    return 10;&amp;#125;",
          date: "Sun Jan 18 2026 16:48:21 GMT+0800",
          updated: "Sun Jan 18 2026 16:49:03 GMT+0800",
          cover: "/images/bg1.webp",
        };
      </script>
        
<script src="/js/insert_highlight.js" data-pjax></script>

      
<script src="/js/tabs.js" data-pjax defer></script>

      <script type="module" data-pjax>
        (async () => {
          const PhotoSwipeLightbox = (await safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe-lightbox.esm.min.js", "sha384-DiL6M/gG+wmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF/N6lrZi/")).default;
          const initPswp = (gallery, children) => {
            if (_$$(`${gallery} ${children}`).length > 0) {
              new PhotoSwipeLightbox({
                gallery,
                children,
                pswpModule: () => safeImport("https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8+oTJ7m3DfYEWX1fu1scuS4+s")
              }).init();
            }
          }
          const pswp = () => {
            initPswp('.article-entry', 'a.article-gallery-item');
            initPswp('.article-gallery', 'a.article-gallery-item');
          }
          pswp();
        })();
      </script>
        


  </div>
</div>


  <script>
    console.log(String.raw`%c 
 ______     ______     __     __    __     __  __    
/\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
\ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
 \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
  \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                  
`,'color: #ff5252;')
    console.log('%c Theme.Reimu v' + '1.11.2' + ' %c https://github.com/D-Sketon/hexo-theme-reimu ', 'color: white; background: #ff5252; padding:5px 0;', 'padding:4px;border:1px solid #ff5252;')
  </script>
  


  
<script src="https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js" integrity="sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S" crossorigin="anonymous" async></script>


<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then((registrations) => {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }
</script>




  </body>
  </html>
